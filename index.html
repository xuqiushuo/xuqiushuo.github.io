<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>xuqiushuo&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="xuqiushuo&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="xuqiushuo&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xuqiushuo&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="xuqiushuo&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xuqiushuo&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mem-manage-md" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/mem-manage-md/" class="article-date">
  <time datetime="2019-03-24T13:01:58.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/mem-manage-md/">mem_manage.md</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##前言：<br>计算机中的内存是分区来管理的，程序和程序之间的内存是独立的，不能互相访问，而每个程序的内存也是分区管理的，一个应用程序所占的内存可以分为很多个区域，通常叫内存四区：</p>
<h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p>　　程序被操作系统加载到内存的时候，所有的可执行代码（程序代码指令、常量字符串等）都加载到代码区，这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。<br>　　注意：”int a = 0;”语句可拆分成”int a;”和”a = 0”，定义变量a的”int a;”语句并不是代码，它在程序编译时就执行了，并没有放到代码区，放到代码区的只有”a = 0”这句。</p>
<h3 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h3><p>　　静态区存放程序中所有的全局变量和静态变量。</p>
<h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>　　栈（stack）是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们不需要考虑。栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出。栈有以下特点：<br>每个线程都有自己专属的栈；<br>栈的最大尺寸固定，超出则引起栈溢出；<br>变量离开作用域后栈上的内存会自动释放。</p>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>　　堆（heap）和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序。更重要的是堆是一个大容器，它的容量要远远大于栈。一般比较复杂的数据类型都是放在堆中。但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。对于一个32位操作系统，最大管理管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序，一个用户程序理论上可以使用3G的内存空间。堆上的内存必须手动释放（C/C++），除非语言执行环境支持GC（如C#在.NET上运行就有垃圾回收机制，jvm也有垃圾回收机制）。<br>　　堆内存的分配和释放：malloc与free<br>　　malloc函数用来在堆中分配指定大小的内存，单位为字节（Byte），函数返回void * 指针；free负责在堆中释放malloc分配的内存。malloc与free一定成对使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/mem-manage-md/" data-id="cjtmxufi400021o7rszyt9ixq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MD5算法及token生成" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/MD5算法及token生成/" class="article-date">
  <time datetime="2019-03-18T15:42:08.000Z" itemprop="datePublished">2019-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/18/MD5算法及token生成/">MD5算法及token生成</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、MD5算法<br>1.1 MD5简介<br>MD5的全称是Message-Digest Algorithm 5，在90年代初由MIT的计算机科学实验室和RSA Data Security Inc发明，经MD2、MD3和MD4发展而来。<br>　　MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。<br>　　MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。<br>MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的.MD5算法本身是哈希算法。</p>
<p>1.2  算法原理<br>MD5算法对输入任意长度的消息进行运行，产生一个128位的消息摘要。<br>a、数据填充<br>对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满足X/512=448。根据此公式得出需要填充的数据长度。<br>填充方法：在消息后面进行填充，填充第一位为1，其余为0。<br>b、添加消息长度<br>在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。<br>在此步骤进行完毕后，最终消息长度就是512的整数倍。<br>c、数据处理<br>准备需要用到的数据：<br>4个常数： A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;<br>4个函数：F(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z); G(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z));  H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z));<br>把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行计算，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量为最后的结果，即MD5值</p>
<p>二、基于 Token 的身份验证方法及token的生成<br>2.1<br>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：<br>客户端使用用户名跟密码请求登录<br>b.      服务端收到请求，去验证用户名与密码<br>c.      验证成功后，服务端会通过MD5计算签发一个 Token，再把这个 Token 发送给客户端<br>d.      客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里<br>e.      客户端每次向服务端请求资源的时候需要带着服务端签发的 Token<br>f.       服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
<p>2.2 token生成<br>1.获取web传来的username及password，结合当前时间，将其拷贝给数据块md5inbuf，运用MD5加密算法进行计算</p>
<p>（<code>）
static void createToken(char *userName, char* password, char* out, UINT8 len)
{   
    char md5inbuf[612];
    unsigned char md5Value_TB[MD5_DIGEST_LEN] = {0};   //存放加密信息
    char tmpOutBuf[MD5_DIGEST_LEN] = {0};      //存放加密结果
    UINT32 tmp = 0;
    struct timeval tv;   
    gettimeofday(&amp;tv, NULL);     
    tmp = tv.tv_sec % NSECS_IN_USEC + tv.tv_usec / NSECS_IN_MSEC;   
    printf(&quot;userName = %s, password = %s, tmp =%d&quot;, userName, password, tmp);
    UTIL_SNPRINTF(md5inbuf, sizeof(md5inbuf), &quot;%s%s%d&quot;, userName, password,tmp);    
    MD5_encrypt(md5Value_TB, (unsigned char*)md5inbuf);
    hex2ascii(md5Value_TB, MD5_DIGEST_LEN, tmpOutBuf);
    UTIL_STRNCPY(out, tmpOutBuf, len);
}
（</code>）</p>
<p>2.运用结构体MD5Context，初始化（数据自定义），将传入的数据更新进去（计算加密），最终生成结果<br>(<code>`</code>)<br>typedef struct MD5Context {<br>  u_int32_t buf[4];<br>  u_int32_t bits[2];<br>  u_char in[64];<br>} MD5Context;<br>void MD5_encrypt(unsigned char <em>out, const unsigned char </em>in)<br>{<br>    MD5Context ctx;<br>    MD5Init( &amp;ctx );   //初始化<br>    MD5Update(&amp;ctx, in, strlen((char<em>)in));  //对欲加密的字符进行加密<br>    MD5Final(out, &amp;ctx);   //获得最终结果<br>}<br>void MD5Init(struct MD5Context </em>ctx)<br>{<br>        ctx-&gt;buf[0] = 0x67452301;<br>        ctx-&gt;buf[1] = 0xefcdab89;<br>        ctx-&gt;buf[2] = 0x98badcfe;<br>        ctx-&gt;buf[3] = 0x10325476;<br>        ctx-&gt;bits[0] = 0;<br>        ctx-&gt;bits[1] = 0;<br>}<br>/*</p>
<ul>
<li>Update context to reflect the concatenation of another buffer full</li>
<li>of bytes.<br><em>/<br>void<br>MD5Update(struct MD5Context </em>ctx, u_char const *buf, u_int len)<br>{<pre><code>register u_int32_t t;
/* Update bitcount */
t = ctx-&gt;bits[0];
if ((ctx-&gt;bits[0] = t + ((u_int32_t) len &lt;&lt; 3)) &lt; t)
        ctx-&gt;bits[1]++;        /* Carry from low to high */
ctx-&gt;bits[1] += len &gt;&gt; 29;
t = (t &gt;&gt; 3) &amp; 0x3f;        /* Bytes already in shsInfo-&gt;data */
/* Handle any leading odd-sized chunks */
if (t) {
        u_char *p = (u_char *) ctx-&gt;in + t;
        t = 64 - t;
        if (len &lt; t) {
                memmove(p, buf, len);
                return;
        }
        memmove(p, buf, t);
        byteReverse(ctx-&gt;in, 16);   //对字符串元素进行分组---4个一组，并进行移位或运算，生成新的数据（原本64个元素，生成16个）
        MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);
        buf += t;
        len -= t;
}
/* Process data in 64-byte chunks */
</code></pre></li>
</ul>
<pre><code>while (len &gt;= 64) {
        memmove(ctx-&gt;in, buf, 64);
        byteReverse(ctx-&gt;in, 16);
        MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);
        buf += 64;
        len -= 64;
}

/* Handle any remaining bytes of data. */

memmove(ctx-&gt;in, buf, len);
</code></pre><p>}</p>
<p>/*</p>
<ul>
<li>Final wrapup - pad to 64-byte boundary with the bit pattern</li>
<li>1 0<em> (64-bit count of bits processed, MSB-first)
</em>/<br>void<br>MD5Final(u_char digest[16], struct MD5Context *ctx)<br>{<pre><code>u_int count;
u_char *p;
/* Compute number of bytes mod 64 */
count = (ctx-&gt;bits[0] &gt;&gt; 3) &amp; 0x3F;
/* Set the first char of padding to 0x80.  This is safe since there is
   always at least one byte free */
p = ctx-&gt;in + count;
*p++ = 0x80;
/* Bytes of padding needed to make 64 bytes */
count = 64 - 1 - count;
/* Pad out to 56 mod 64 */
if (count &lt; 8) {
        /* Two lots of padding:  Pad the first block to 64 bytes */
        memset(p, 0, count);
        byteReverse(ctx-&gt;in, 16);
        MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);
        /* Now fill the next block with 56 bytes */
        memset(ctx-&gt;in, 0, 56);
} else {
        /* Pad block to 56 bytes */
        memset(p, 0, count - 8);
}
byteReverse(ctx-&gt;in, 14);
/* Append length in bits and transform */
((u_int32_t *) ctx-&gt;in)[14] = ctx-&gt;bits[0];
((u_int32_t *) ctx-&gt;in)[15] = ctx-&gt;bits[1];
MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);
byteReverse((u_char *) ctx-&gt;buf, 4);
memmove(digest, ctx-&gt;buf, 16);
memset(ctx, 0, sizeof(struct MD5Context));        /* In case it&apos;s sensitive */
</code></pre>}<br>(<code>`</code>)</li>
</ul>
<p>3.算法主要构成函数：byteReverse及MD5Transform，我在网上查了一下，byteReverse函数与Decode函数一样<br>(<code>`</code>)<br>/*</p>
<ul>
<li>Note: this code is harmless on little-endian machines.<br><em>/<br>static void<br>byteReverse(u_char </em>buf, u_int longs)<br>{<pre><code>u_int32_t t;
do {
        t = (u_int32_t) ((u_int) buf[3] &lt;&lt; 8 | buf[2]) &lt;&lt; 16 |
            ((u_int) buf[1] &lt;&lt; 8 | buf[0]);
        *(u_int32_t *) buf = t;
        buf += 4;
} while (--longs);
</code></pre>}<br>/<em> This is the central step in the MD5 algorithm. </em>/<br>#define MD5STEP(f, w, x, y, z, data, s) \<pre><code>( w += f(x, y, z) + data,  w = w&lt;&lt;s | w&gt;&gt;(32-s),  w += x )       
</code></pre>/*</li>
<li>The core of the MD5 algorithm, this alters an existing MD5 hash to</li>
<li>reflect the addition of 16 longwords of new data.  MD5Update blocks</li>
<li>the data and converts bytes into longwords for this routine.<br>*/<br>static void<br>MD5Transform(u_int32_t buf[4], u_int32_t const in[16])<br>{<pre><code>register u_int32_t a, b, c, d;
a = buf[0];
b = buf[1];
c = buf[2];
d = buf[3];
MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
buf[0] += a;
buf[1] += b;
buf[2] += c;
buf[3] += d;
</code></pre>}<br>/<em> Decodes input (unsigned char) into output (UINT4). Assumes len is<br>a multiple of 4. </em>/<br>/<em>与上面的函数正好相反，这一个把字符形式的缓冲区中的数据copy到4字节的整数中（即以整数形式保存）<br>output：保存转换出的整数<br>input：欲转换的字符缓冲区<br>len：输入的字符缓冲区的长度，要求是4的整数倍
</em>/<br>static void Decode(UINT4 <em>output, unsigned char </em>input,unsigned int   len)<br>{<br>unsigned int i, j;<br>for(i = 0, j = 0; j &lt; len; i++, j += 4)<br>output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) |<br> (((UINT4)input[j+2]) &lt;&lt; 16) | (((UINT4)input[j+3]) &lt;&lt; 24);<br>}<br>(<code>`</code>)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/18/MD5算法及token生成/" data-id="cjtmxufig00051o7ryd5ovqq4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-5iomodel" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/17/5iomodel/" class="article-date">
  <time datetime="2019-03-17T14:03:10.196Z" itemprop="datePublished">2019-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/17/5iomodel/">常见五种IO模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先理一下内核空间和用户空间，操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作kernel，保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<p>五种IO模型包括：阻塞IO、非阻塞IO、信号驱动IO、IO多路复用、异步IO。其中，前四个被称为同步IO。<br>先放一下看到的知乎<a href="https://www.zhihu.com/people/levin-43-90/activities" target="_blank" rel="noopener">levin</a>写的通俗理解：</p>
<p>1.阻塞I/O模型<br>老李去火车站买票，排队三天买到一张退票。<br>耗费：在车站吃喝拉撒睡 3天，其他事一件没干。</p>
<p>2.非阻塞I/O模型<br>老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。</p>
<p>3.I/O复用模型<br>1.select/poll<br>老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。<br>耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次<br>2.epoll<br>老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。<br>耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话</p>
<p>4.信号驱动I/O模型<br>老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。<br>耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话</p>
<p>5.异步I/O模型<br>老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。<br>耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话</p>
<p>##1.阻塞IO<br>阻塞IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。</p>
<p>##2.非阻塞IO<br>同步非阻塞采用轮询（polling）方式，也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
<p>##3.IO多路复用<br>非阻塞IO是主动轮询的方式，但会消耗大量时间，用户进程不断轮询也是一种浪费，而且同时可能有多个任务同时进行，IO多路复用则采用循环轮询方式，是内核完成的，Linux下是采用select、poll、epoll 方法（epoll 比 poll、select 效率高）。select轮询相对非阻塞的轮询的区别在于—前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理，数据到达监视的任务是由kernel完成。<br>基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。<br>在IO multiplexing 模型中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。<br>同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。</p>
<p>以上，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大，因为非阻塞轮询可能需要消耗的时间和资源很少。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）<br>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。并发是同时进行的任务数，并行是同时工作的无力资源数量（CPU核数），通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。</p>
<p>##4.信号驱动IO（不常用）<br>首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>
<p>##5.异步IO<br>相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。数据拷贝到用户进程完成后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/17/5iomodel/" data-id="cjtmxufi600041o7r2eb8mz5n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-shellscript" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/shellscript/" class="article-date">
  <time datetime="2018-12-09T10:36:33.000Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/shellscript/">shell启动脚本</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简单记录shell脚本语法</p>
<p>sfSrc=<code>s show | grep SfCfgName | cut -d &quot;:&quot; -f 2</code><br>  sfDst=<code>ls usr/S304/etc/oversea</code><br>  if [ $sfSrc != $sfDst ]; then<br>    echo “SfCfgName is not right”<br>    s SfCfgName oversea/$sfDst<br>  else<br>    echo “SfCfgName is right”<br>  fi</p>
<p>脚本需要判断升级软件的SF与当前SF是否一致，否则需要修改，直接用s SfCfgName oversea/$sfDst命令修改SF</p>
<p>主要就是上面这段代码，当时分割字符方法不熟悉，查了一下并整理了笔记</p>
<p>shell语法整理了一些，包括一些基础命令： <a href="http://note.youdao.com/noteshare?id=ac45a75b8c041019021a68d184852b3b" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=ac45a75b8c041019021a68d184852b3b</a></p>
<h1 id="s-show-grep-SfCfgName"><a href="#s-show-grep-SfCfgName" class="headerlink" title="s show | grep SfCfgName"></a>s show | grep SfCfgName</h1><p>SfCfgName:oversea/tejas-4f0-wifi</p>
<p>sfSrc=<code>s show | grep SfCfgName | cut -d &quot;/&quot; -f 2</code></p>
<p>#s show | grep SfCfgName | cut -d “/“ -f 2</p>
<p>tejas-4f0-wifi</p>
<p>截取后就是tejas-4f0-wifi</p>
<p>cut是一个选取命令，就是将一段数据经过分析，取出我们想要的。一般来说，选取信息通常是针对“行”来进行分析的，并不是整篇信息分析的。</p>
<p>其语法格式为： </p>
<p>cut [-bn] [file] 或 cut [-c] [file] 或 cut [-df] [file] </p>
<p>使用说明: </p>
<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 </p>
<p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 </p>
<p>主要参数 </p>
<p>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 </p>
<p>-c ：以字符为单位进行分割。 </p>
<p>-d ：自定义分隔符，默认为制表符。 </p>
<p>-f ：与-d一起使用，指定显示哪个区域。 </p>
<p>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/09/shellscript/" data-id="cjtmxufi500031o7r13ciulmw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-first" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/first/" class="article-date">
  <time datetime="2018-12-09T10:07:46.723Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/first/">博客push失败原因</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在github上搭建个人博客，hexo已经部署完毕，本地访问也没有问题，但最后hexo d就是push不上去</p>
<p>检查了deploy，看不出有什么问题，后面百度了一下，发现有个巨坑，type: git中间必须有个空格！！！！</p>
<p>deploy:</p>
<p>  type: git</p>
<p>  repository: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx/xxx.github.io.git</p>
<p>  branch: master</p>
<p>修改就可以hexo d 自动push了</p>
<p><img src="/Users/xqs/Desktop/hexo.png" alt="avatar"> </p>
<p>感谢提供答案的朋友：<a href="https://segmentfault.com/q/1010000002764038" target="_blank" rel="noopener">https://segmentfault.com/q/1010000002764038</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/09/first/" data-id="cjtmxufhv00001o7revh9ozqj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/25/hello-world/" class="article-date">
  <time datetime="2018-11-25T06:56:23.805Z" itemprop="datePublished">2018-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/25/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/25/hello-world/" data-id="cjtmxufi200011o7rpn95rh68" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/24/mem-manage-md/">mem_manage.md</a>
          </li>
        
          <li>
            <a href="/2019/03/18/MD5算法及token生成/">MD5算法及token生成</a>
          </li>
        
          <li>
            <a href="/2019/03/17/5iomodel/">常见五种IO模型</a>
          </li>
        
          <li>
            <a href="/2018/12/09/shellscript/">shell启动脚本</a>
          </li>
        
          <li>
            <a href="/2018/12/09/first/">博客push失败原因</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>