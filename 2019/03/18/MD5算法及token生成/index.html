<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>MD5算法及token生成 | xuqiushuo&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、MD5算法1.1 MD5简介MD5的全称是Message-Digest Algorithm 5，其本质是哈希算法，经MD2、MD3和MD4发展而来。 MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的">
<meta property="og:type" content="article">
<meta property="og:title" content="MD5算法及token生成">
<meta property="og:url" content="http://yoursite.com/2019/03/18/MD5算法及token生成/index.html">
<meta property="og:site_name" content="xuqiushuo&#39;s blog">
<meta property="og:description" content="一、MD5算法1.1 MD5简介MD5的全称是Message-Digest Algorithm 5，其本质是哈希算法，经MD2、MD3和MD4发展而来。 MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-27T15:53:35.780Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MD5算法及token生成">
<meta name="twitter:description" content="一、MD5算法1.1 MD5简介MD5的全称是Message-Digest Algorithm 5，其本质是哈希算法，经MD2、MD3和MD4发展而来。 MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的">
  
    <link rel="alternate" href="/atom.xml" title="xuqiushuo&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xuqiushuo&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-MD5算法及token生成" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/MD5算法及token生成/" class="article-date">
  <time datetime="2019-03-18T15:42:08.000Z" itemprop="datePublished">2019-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      MD5算法及token生成
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、MD5算法"><a href="#一、MD5算法" class="headerlink" title="一、MD5算法"></a>一、MD5算法</h3><h4 id="1-1-MD5简介"><a href="#1-1-MD5简介" class="headerlink" title="1.1 MD5简介"></a>1.1 MD5简介</h4><pre><code>MD5的全称是Message-Digest Algorithm 5，其本质是哈希算法，经MD2、MD3和MD4发展而来。
MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。
</code></pre><p>　　MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。<br>    MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的。</p>
<h4 id="1-2-算法原理"><a href="#1-2-算法原理" class="headerlink" title="1.2  算法原理"></a>1.2  算法原理</h4><p>MD5算法对输入任意长度的消息进行运行，产生一个128位的消息摘要。<br>a、数据填充<br>对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满足X/512=448。根据此公式得出需要填充的数据长度。<br>填充方法：在消息后面进行填充，填充第一位为1，其余为0。<br>b、添加消息长度<br>在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。<br>在此步骤进行完毕后，最终消息长度就是512的整数倍。<br>c、数据处理<br>准备需要用到的数据：<br>4个常数： A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;<br>4个函数：F(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z); G(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z));  H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z));<br>把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行计算，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量为最后的结果，即MD5值</p>
<h3 id="二、基于-Token-的身份验证方法及token的生成"><a href="#二、基于-Token-的身份验证方法及token的生成" class="headerlink" title="二、基于 Token 的身份验证方法及token的生成"></a>二、基于 Token 的身份验证方法及token的生成</h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：<br>a.      客户端使用用户名跟密码请求登录<br>b.      服务端收到请求，去验证用户名与密码<br>c.      验证成功后，服务端会通过MD5计算签发一个 Token，再把这个 Token 发送给客户端<br>d.      客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里<br>e.      客户端每次向服务端请求资源的时候需要带着服务端签发的 Token<br>f.       服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
<h4 id="2-2-token生成"><a href="#2-2-token生成" class="headerlink" title="2.2 token生成"></a>2.2 token生成</h4><p>1.获取web传来的username及password，结合当前时间，将其拷贝给数据块md5inbuf，运用MD5加密算法进行计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void createToken(char *userName, char* password, char* out, UINT8 len)</span><br><span class="line">&#123;   </span><br><span class="line">    char md5inbuf[612];</span><br><span class="line">    unsigned char md5Value_TB[MD5_DIGEST_LEN] = &#123;0&#125;;   //存放加密信息</span><br><span class="line">    char tmpOutBuf[MD5_DIGEST_LEN] = &#123;0&#125;;      //存放加密结果</span><br><span class="line">    UINT32 tmp = 0;</span><br><span class="line">    struct timeval tv;   </span><br><span class="line">    gettimeofday(&amp;tv, NULL);     </span><br><span class="line">    tmp = tv.tv_sec % NSECS_IN_USEC + tv.tv_usec / NSECS_IN_MSEC;   </span><br><span class="line">    printf(&quot;userName = %s, password = %s, tmp =%d&quot;, userName, password, tmp);</span><br><span class="line">    UTIL_SNPRINTF(md5inbuf, sizeof(md5inbuf), &quot;%s%s%d&quot;, userName, password,tmp);    </span><br><span class="line">    MD5_encrypt(md5Value_TB, (unsigned char*)md5inbuf);</span><br><span class="line">    hex2ascii(md5Value_TB, MD5_DIGEST_LEN, tmpOutBuf);</span><br><span class="line">    UTIL_STRNCPY(out, tmpOutBuf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.运用结构体MD5Context，初始化（数据自定义），将传入的数据更新进去（计算加密），最终生成结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">typedef struct MD5Context &#123;</span><br><span class="line">  u_int32_t buf[4];</span><br><span class="line">  u_int32_t bits[2];</span><br><span class="line">  u_char in[64];</span><br><span class="line">&#125; MD5Context;</span><br><span class="line">void MD5_encrypt(unsigned char *out, const unsigned char *in)</span><br><span class="line">&#123;</span><br><span class="line">    MD5Context ctx;</span><br><span class="line">    MD5Init( &amp;ctx );   //初始化</span><br><span class="line">    MD5Update(&amp;ctx, in, strlen((char*)in));  //对欲加密的字符进行加密</span><br><span class="line">    MD5Final(out, &amp;ctx);   //获得最终结果</span><br><span class="line">&#125;</span><br><span class="line">void MD5Init(struct MD5Context *ctx)</span><br><span class="line">&#123;</span><br><span class="line">        ctx-&gt;buf[0] = 0x67452301;</span><br><span class="line">        ctx-&gt;buf[1] = 0xefcdab89;</span><br><span class="line">        ctx-&gt;buf[2] = 0x98badcfe;</span><br><span class="line">        ctx-&gt;buf[3] = 0x10325476;</span><br><span class="line">        ctx-&gt;bits[0] = 0;</span><br><span class="line">        ctx-&gt;bits[1] = 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * Update context to reflect the concatenation of another buffer full</span><br><span class="line"> * of bytes.</span><br><span class="line"> */</span><br><span class="line">void</span><br><span class="line">MD5Update(struct MD5Context *ctx, u_char const *buf, u_int len)</span><br><span class="line">&#123;</span><br><span class="line">        register u_int32_t t;</span><br><span class="line">        /* Update bitcount */</span><br><span class="line">        t = ctx-&gt;bits[0];</span><br><span class="line">        if ((ctx-&gt;bits[0] = t + ((u_int32_t) len &lt;&lt; 3)) &lt; t)</span><br><span class="line">                ctx-&gt;bits[1]++;        /* Carry from low to high */</span><br><span class="line">        ctx-&gt;bits[1] += len &gt;&gt; 29;</span><br><span class="line">        t = (t &gt;&gt; 3) &amp; 0x3f;        /* Bytes already in shsInfo-&gt;data */</span><br><span class="line">        /* Handle any leading odd-sized chunks */</span><br><span class="line">        if (t) &#123;</span><br><span class="line">                u_char *p = (u_char *) ctx-&gt;in + t;</span><br><span class="line">                t = 64 - t;</span><br><span class="line">                if (len &lt; t) &#123;</span><br><span class="line">                        memmove(p, buf, len);</span><br><span class="line">                        return;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, buf, t);</span><br><span class="line">                byteReverse(ctx-&gt;in, 16);   //对字符串元素进行分组---4个一组，并进行移位或运算，生成新的数据（原本64个元素，生成16个）</span><br><span class="line">                MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);</span><br><span class="line">                buf += t;</span><br><span class="line">                len -= t;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Process data in 64-byte chunks */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        while (len &gt;= 64) &#123;</span><br><span class="line">                memmove(ctx-&gt;in, buf, 64);</span><br><span class="line">                byteReverse(ctx-&gt;in, 16);</span><br><span class="line">                MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);</span><br><span class="line">                buf += 64;</span><br><span class="line">                len -= 64;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Handle any remaining bytes of data. */</span><br><span class="line"></span><br><span class="line">        memmove(ctx-&gt;in, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Final wrapup - pad to 64-byte boundary with the bit pattern</span><br><span class="line"> * 1 0* (64-bit count of bits processed, MSB-first)</span><br><span class="line"> */</span><br><span class="line">void</span><br><span class="line">MD5Final(u_char digest[16], struct MD5Context *ctx)</span><br><span class="line">&#123;</span><br><span class="line">        u_int count;</span><br><span class="line">        u_char *p;</span><br><span class="line">        /* Compute number of bytes mod 64 */</span><br><span class="line">        count = (ctx-&gt;bits[0] &gt;&gt; 3) &amp; 0x3F;</span><br><span class="line">        /* Set the first char of padding to 0x80.  This is safe since there is</span><br><span class="line">           always at least one byte free */</span><br><span class="line">        p = ctx-&gt;in + count;</span><br><span class="line">        *p++ = 0x80;</span><br><span class="line">        /* Bytes of padding needed to make 64 bytes */</span><br><span class="line">        count = 64 - 1 - count;</span><br><span class="line">        /* Pad out to 56 mod 64 */</span><br><span class="line">        if (count &lt; 8) &#123;</span><br><span class="line">                /* Two lots of padding:  Pad the first block to 64 bytes */</span><br><span class="line">                memset(p, 0, count);</span><br><span class="line">                byteReverse(ctx-&gt;in, 16);</span><br><span class="line">                MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);</span><br><span class="line">                /* Now fill the next block with 56 bytes */</span><br><span class="line">                memset(ctx-&gt;in, 0, 56);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                /* Pad block to 56 bytes */</span><br><span class="line">                memset(p, 0, count - 8);</span><br><span class="line">        &#125;</span><br><span class="line">        byteReverse(ctx-&gt;in, 14);</span><br><span class="line">        /* Append length in bits and transform */</span><br><span class="line">        ((u_int32_t *) ctx-&gt;in)[14] = ctx-&gt;bits[0];</span><br><span class="line">        ((u_int32_t *) ctx-&gt;in)[15] = ctx-&gt;bits[1];</span><br><span class="line">        MD5Transform(ctx-&gt;buf, (u_int32_t *) ctx-&gt;in);</span><br><span class="line">        byteReverse((u_char *) ctx-&gt;buf, 4);</span><br><span class="line">        memmove(digest, ctx-&gt;buf, 16);</span><br><span class="line">        memset(ctx, 0, sizeof(struct MD5Context));        /* In case it&apos;s sensitive */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.算法主要构成函数：byteReverse及MD5Transform，我在网上查了一下，byteReverse函数与Decode函数一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Note: this code is harmless on little-endian machines.</span><br><span class="line"> */</span><br><span class="line">static void</span><br><span class="line">byteReverse(u_char *buf, u_int longs)</span><br><span class="line">&#123;</span><br><span class="line">        u_int32_t t;</span><br><span class="line">        do &#123;</span><br><span class="line">                t = (u_int32_t) ((u_int) buf[3] &lt;&lt; 8 | buf[2]) &lt;&lt; 16 |</span><br><span class="line">                    ((u_int) buf[1] &lt;&lt; 8 | buf[0]);</span><br><span class="line">                *(u_int32_t *) buf = t;</span><br><span class="line">                buf += 4;</span><br><span class="line">        &#125; while (--longs);</span><br><span class="line">&#125;</span><br><span class="line">/* This is the central step in the MD5 algorithm. */</span><br><span class="line">#define MD5STEP(f, w, x, y, z, data, s) \</span><br><span class="line">        ( w += f(x, y, z) + data,  w = w&lt;&lt;s | w&gt;&gt;(32-s),  w += x )       </span><br><span class="line">/*</span><br><span class="line"> * The core of the MD5 algorithm, this alters an existing MD5 hash to</span><br><span class="line"> * reflect the addition of 16 longwords of new data.  MD5Update blocks</span><br><span class="line"> * the data and converts bytes into longwords for this routine.</span><br><span class="line"> */</span><br><span class="line">static void</span><br><span class="line">MD5Transform(u_int32_t buf[4], u_int32_t const in[16])</span><br><span class="line">&#123;</span><br><span class="line">        register u_int32_t a, b, c, d;</span><br><span class="line">        a = buf[0];</span><br><span class="line">        b = buf[1];</span><br><span class="line">        c = buf[2];</span><br><span class="line">        d = buf[3];</span><br><span class="line">        MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);</span><br><span class="line">        MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);</span><br><span class="line">        MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);</span><br><span class="line">        MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);</span><br><span class="line">        MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);</span><br><span class="line">        MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);</span><br><span class="line">        MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);</span><br><span class="line">        MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);</span><br><span class="line">        MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);</span><br><span class="line">        MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);</span><br><span class="line">        MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);</span><br><span class="line">        MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);</span><br><span class="line">        MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);</span><br><span class="line">        MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);</span><br><span class="line">        MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);</span><br><span class="line">        MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);</span><br><span class="line">        MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);</span><br><span class="line">        MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);</span><br><span class="line">        MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);</span><br><span class="line">        MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);</span><br><span class="line">        MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);</span><br><span class="line">        MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);</span><br><span class="line">        MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);</span><br><span class="line">        MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);</span><br><span class="line">        MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);</span><br><span class="line">        MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);</span><br><span class="line">        MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);</span><br><span class="line">        MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);</span><br><span class="line">        MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);</span><br><span class="line">        MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);</span><br><span class="line">        MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);</span><br><span class="line">        MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);</span><br><span class="line">        MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);</span><br><span class="line">        MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);</span><br><span class="line">        MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);</span><br><span class="line">        MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);</span><br><span class="line">        MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);</span><br><span class="line">        MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);</span><br><span class="line">        MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);</span><br><span class="line">        MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);</span><br><span class="line">        MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);</span><br><span class="line">        MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);</span><br><span class="line">        MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);</span><br><span class="line">        MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);</span><br><span class="line">        MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);</span><br><span class="line">        MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);</span><br><span class="line">        MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);</span><br><span class="line">        MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);</span><br><span class="line">        MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);</span><br><span class="line">        MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);</span><br><span class="line">        MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);</span><br><span class="line">        MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);</span><br><span class="line">        MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);</span><br><span class="line">        MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);</span><br><span class="line">        MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);</span><br><span class="line">        MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);</span><br><span class="line">        MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);</span><br><span class="line">        MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);</span><br><span class="line">        MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);</span><br><span class="line">        MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);</span><br><span class="line">        MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);</span><br><span class="line">        MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);</span><br><span class="line">        MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);</span><br><span class="line">        MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);</span><br><span class="line">        buf[0] += a;</span><br><span class="line">        buf[1] += b;</span><br><span class="line">        buf[2] += c;</span><br><span class="line">        buf[3] += d;</span><br><span class="line">&#125;</span><br><span class="line">/* Decodes input (unsigned char) into output (UINT4). Assumes len is</span><br><span class="line">   a multiple of 4. */</span><br><span class="line">/*与上面的函数正好相反，这一个把字符形式的缓冲区中的数据copy到4字节的整数中（即以整数形式保存）</span><br><span class="line">output：保存转换出的整数</span><br><span class="line">input：欲转换的字符缓冲区</span><br><span class="line">len：输入的字符缓冲区的长度，要求是4的整数倍</span><br><span class="line">*/</span><br><span class="line">static void Decode(UINT4 *output, unsigned char *input,unsigned int   len)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i, j;</span><br><span class="line">for(i = 0, j = 0; j &lt; len; i++, j += 4)</span><br><span class="line">   output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) |</span><br><span class="line">    (((UINT4)input[j+2]) &lt;&lt; 16) | (((UINT4)input[j+3]) &lt;&lt; 24);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/18/MD5算法及token生成/" data-id="cjtrf6w860006rrfmxcqpyr1w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/24/mem-manage-md/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          关于内存管理
        
      </div>
    </a>
  
  
    <a href="/2019/03/17/5iomodel/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">常见五种IO模型</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/27/ipv6服务器及环境搭建/">ipv6服务器及环境搭建</a>
          </li>
        
          <li>
            <a href="/2019/03/24/mem-manage-md/">关于内存管理</a>
          </li>
        
          <li>
            <a href="/2019/03/18/MD5算法及token生成/">MD5算法及token生成</a>
          </li>
        
          <li>
            <a href="/2019/03/17/5iomodel/">常见五种IO模型</a>
          </li>
        
          <li>
            <a href="/2018/12/09/shellscript/">shell启动脚本</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>